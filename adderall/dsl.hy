;; adderall - miniKanren in Hy
;; Copyright (C) 2014, 2015, 2016  Gergely Nagy <algernon@madhouse-project.org>
;;
;; This library is free software: you can redistribute it and/or
;; modify it under the terms of the GNU Lesser General Public License
;; as published by the Free Software Foundation, either version 3 of
;; the License, or (at your option) any later version.
;;
;; This library is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
;; Lesser General Public License for more details.
;;
;; You should have received a copy of the GNU Lesser General Public
;; License along with this program. If not, see <http://www.gnu.org/licenses/>.

(import [functools [reduce partial]]
        [hy [HySymbol HyExpression HyList HyKeyword]]
        [hy.contrib.walk [prewalk]])
(import [cons [cons car cdr]])
(import [adderall.internal [unify lvar? seq? reify
                            LVar unbound interleave cons]])

(require [hy.contrib.walk [let]])
(require [monaxhyd.core [defmonad monad with-monad]])
(require [adderall.internal [defn-alias defmacro-alias]])

;; Top level stuff

(eval-and-compile
 (defn --prep-fresh-vars-- [vars]
   (setv fresh-vars [])
   (for [x vars]
     (.extend fresh-vars `[~x (LVar (gensym '~x))]))
   fresh-vars)

 (defn --prep-lvars-from-expr-- [lvars expr]
   (when (and (instance? HySymbol expr)
              (.startswith expr "?"))
     (.add lvars expr))
   expr))

(defmacro/g! lazy-run [n vars &rest goals]
  `(do
     (require [hy.contrib.walk [let :as ~g!let]])
     (~g!let [~@(--prep-fresh-vars-- vars)
              ~g!res (fn []
                       (for [~g!s ((all ~@goals) (,))]
                         (when (none? ~g!s)
                           (continue))
                         (yield (reify (if (= (len ~vars) 1)
                                           (first ~vars)
                                           [~@vars])
                                       ~g!s))))]
      (if ~n
          (islice (~g!res) 0 ~n)
          (~g!res)))))

(defmacro lazy-run* [vars &rest goals]
  `(lazy-run None ~vars ~@goals))

(defmacro run [n vars &rest goals]
  "Evaluate miniKanren goals and obtain the variables that satisfy them.

Examples
--------
  => (run None [q] succeed)
  [<'_.0'>]
  => (run 1 [q] (≡ q 1))
  [1]
  => (run 1 [q] (membero q [1 2 3]))
  [1]
  => (run 2 [q] (membero q [1 2 3]))
  [1, 2]

Parameters
----------
n: int, or None
  The number of results to return.  If `None`, return all results.
  XXX: Depending on the goals, there may be infinitely many results.

vars: symbols
  Symbols to be used as logic variables/`LVar`s and output in the results.
  Un-unified logic variables are given the textual representation `<'_.x'>`,
  where `x` is an integer index corresponding to variable in `vars`.

goals: goals (in the miniKanren DSL)
  The goals to be satisfied.

Results
-------
out: A sequence of lists containing the reified `vars` values that satisfy the
goals in `goals`.
"
  `(list (lazy-run ~n ~vars ~@goals)))

(defmacro-alias [run1 run¹] [vars &rest args]
  "Return a single result from `run` (i.e. `n` set to `1`).

See `run`."
  `(first (run 1 ~vars ~@args)))

(defmacro run* [vars &rest args]
  "Return all results from `run` (i.e. `n` set to `None`).

See `run`."
  `(run None ~vars ~@args))

(defmacro/g! fresh [vars &rest goals]
  "Introduce new logic variables.

This is a means of adding logic variables outside of the arguments to `run`.

Examples
--------

  => (run* [q] (fresh [x]))
  [<'_.0'>]

Parameters
----------
vars: symbols
  New logic variables.

goals: goals
  Goals to be satisfied by the generated `fresh` goal.

Results
-------
out: A goal stating the given relation between its arguments.
"
  (if goals
      `(do
         (require [hy.contrib.walk [let :as ~g!let]])
         (~g!let [~@(--prep-fresh-vars-- vars)]
          (all ~@goals)))
    `succeed))

(defmacro/g! prep [&rest goals]
  "Automatically add fresh logic variables using a `?` prefix naming.

The goals within the body of a `prep` goal will recognize symbols prefixed with
question marks as fresh logic variables.

In other words,
  (prep (≡ ?x 1)) => (fresh [x] (≡ x 1))

Parameters
----------
goals: goals
  These goals have access to the `LVar`s generated by the `?` prefix in the
  body of this macro.

Results
-------
out: A goal stating the given relation between its arguments.
"
  (let [g!lvars (set [])]
    (prewalk (partial --prep-lvars-from-expr-- g!lvars) (HyList goals))
    (setv g!lvars (HyList g!lvars))
    `(fresh ~g!lvars ~@goals)))

(eval-and-compile
 (defn project-binding [s]
   (fn [var]
     `[~var (reify ~(HySymbol (+ "__" var)) ~s)]))

 (defn project-bindings [vars s]
   (setv bindings [])
   (for [var vars]
     (.extend bindings ((project-binding s) var)))
   bindings)

 (defn --prep-project-vars-- [vars]
   (setv project-vars [])
   (for [x vars]
     (.extend project-vars `[~(HySymbol (+ "__" x)) ~x]))
   project-vars))

(defmacro/g! project [vars &rest goals]
  "Access a value associated with a logic variable.

Within the scope of `project` logic variables are reified to allow direct
host-language (e.g. Hy, Python) interaction.  It intervenes with the process of
satisfying miniKanren goals, and, as such, can be a means of direct user
intervention for debugging purposes.

XXX: `project` is considered \"impure\" in miniKanren, since it is not purely
relational and can depend on the order of goal evaluation.

Examples
--------
  => (run* [q] (fresh [x] (≡ x 2) (≡ q (type x))))
  [LVar]
  => (run* [q] (fresh [x] (≡ x 2) (project [x] (≡ q (type x)))))
  [<class 'int'>]

Parameters
----------
vars: `LVar`s
  The objects to be temporarily reified.

goals: goals
  Goals with access to the projected values of `vars`.

Results
-------
out: A goal stating the given relation between its arguments.
"
  (if goals
    `(fn [~g!s]
       (do
         (require [hy.contrib.walk [let :as ~g!let]])
         (~g!let [~@(--prep-project-vars-- vars)]
          (~g!let [~@(project-bindings vars g!s)]
           ((all ~@goals) ~g!s)))))
    `succeed))

(deftag U [n]
  "Shorthand for unbound"
  `(unbound ~n))

;; Goals

(defn-alias [≡ == unifyo] [u v]
  "Fundamental unification goal.

This is the main means of assigning values to logic variables in miniKanren.

Examples
--------
  => (run* [q] (== q 1))
  [1]
  => (run* [q] (== q q))
  [<'_.0'>]
  => (run* [q v] (== q v))
  [[<'_.0'>, <'_.0'>]]
  => (run* [q v] (== q (fresh [x] x)))
  [[<'_.0'>, <'_.1'>]]

Parameters
----------
u: symbol or `LVar`
  An object to unify with `v`.

v: symbol or `LVar`
  An object to unify with `u`.

Results
-------
out: A goal stating the given relation between its arguments.
"
  (fn [s]
    (yield (unify u v s))))

(defn succeed [s]
  "The goal signifying 'success'."
  (yield s))
(setv s# succeed)

(defn fail [s]
  "The goal signifying 'failure' or 'unsuccessful'."
  (iter (,)))
(setv u# fail)

(deftag ? [v]
  "Shorthand for the creation of a unique `LVar`"
  `(LVar (gensym '~v)))

(defn m-bind-sequence [mv f]
  (when mv
    (let [vs (list mv)]
         (chain (f (first vs))
                (m-bind-sequence (list (rest vs)) f)))))

(defmonad logic-m
  [m-result (fn [v] (list v))
   m-bind   m-bind-sequence
   m-zero   []
   m-plus   (fn [mvs]
              (chain #* mvs))])

(defmonad logic-interleave-m
  [m-result (fn [v] (list v))
   m-bind   m-bind-sequence
   m-zero   []
   m-plus   (fn [mvs]
              (interleave mvs))])

(defn all [&rest goals]
  "A goal that succeeds when all of its constituent goals succeed.

TODO: Add an illustrative example.

Parameters
----------
goals: goals

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (if goals
    (reduce (fn [g1 g2]
              (fn [s]
                (for [opt-s1 (g1 s)]
                  (unless (none? opt-s1)
                    (for [opt-s2 (g2 opt-s1)]
                      (yield opt-s2)))))) goals)
    succeed))

(defn-alias [allⁱ alli] [&rest goals]
  "A goal that succeeds when all of its constituent goals succeed.

This version interleaves its results.

See `all`

TODO: Add an illustrative example.

Parameters
----------
goals: goals

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (if goals
    (with-monad logic-interleave-m
      (reduce (fn [chain-expr step]
                (fn [v]
                  (if (empty? v)
                    (step v)
                    (m-bind (chain-expr v) step))))
              goals
              m-result))
    succeed))

(eval-and-compile
 (defn __subst-else [conds]
   (map (fn [c]
          (if (= (first c) 'else)
              (HyExpression `(cons succeed ~(list (rest c))))
            c)) conds)))

(defmacro-alias [condᵉ conde] [&rest cs]
  "Logical conjunction and disjunction of goals.

This is analogous to the Lisp version of `cond`; however, in miniKanren
conditions are not necessarily mutually exclusive.  In other words, valid
unifications/substitutions corresponding to each condition/branch are
generated.

Examples
--------
  => (run* [q] (condᵉ [(== 1 q) (== 2 q)]))
  []
  => (run* [q] (condᵉ [(== 1 q)] [(== 2 q)] (else u#)))
  [1, 2]
  => (run* [q] (condᵉ [(== 1 q)] [(== 2 q)] (else s#)))
  [1, 2, <'_.0'>]

Parameters
----------
cs: goals
  Each element in this sequence is a list of goals evaluated logically as
  [g11 && g12 ...] || [g21 g22 ... ] || ...
  The symbol `else` can be used in a final conjunction with another goal.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (with-gensyms [s c with-monad]
    (let [ncs (__subst-else cs)]
         `(do
            (require [monaxhyd.core [with-monad :as ~with-monad]])
            (~with-monad logic-m
              (fn [~s]
                (m-plus (map (fn [~c]
                               ((all #* ~c) ~s))
                             [~@ncs]))))))))

(defmacro-alias [condⁱ condi] [&rest cs]
  "Logical conjunction and disjunction of goals.

This version interleaves its values.

See `condᵉ`.

Examples
--------
  TODO: Add an illustrative example.

Parameters
----------
goals: goals
  Each element in this sequence is a list of goals evaluated logically as
  [g11 && g12 ...] || [g21 g22 ... ] || ...
  The symbol `else` can be used in a final conjunction with another goal.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (with-gensyms [s c with-monad]
    (let [ncs (__subst-else cs)]
         `(do
            (require [monaxhyd.core [with-monad :as ~with-monad]])
            (~with-monad logic-interleave-m
             (fn [~s]
               (m-plus (map (fn [~c]
                              ((all #* ~c) ~s))
                            [~@ncs]))))))))

(defn-alias [consᵒ conso] [f r l]
  "A goal representing the `cons` operator.

Example
-------
  => (run* [q] (consᵒ 1 [2 3] q))
  [[1, 2, 3]]
  => (run* [q] (consᵒ q [3] [2 3]))
  [2]
  => (run* [q] (consᵒ 1 q [1 2 3]))
  [[2, 3]]

Parameters
----------
f: form or `LVar`
  The object representing the car.
r: form or `LVar`
  The object representing the cdr.
l: form or `LVar`
  The object representing the cons object for which `f` and `r` are the car and
  cdr, respectively.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (≡ (cons f r) l)
  ;; XXX: This is a rather limiting assumption relative to `cons` semantics.
  ;; Returning a list-pair like this says:
  ;; (conso f r l) == (== [f r] l) == (== (cons f '(r)) l)
  ;;
  ;; So, for `r` an LVar, we're implicitly forcing an interpretation of
  ;; `r` as a list, and, with otherwise consistent use of `cons`, it would
  ;; never unify with a plain symbol.
  ;;
  ;; Instead, we could use `conde` to consider both cases, no?
  #_(≡ [f r] l))

(defn-alias [firstᵒ firsto] [l a]
  "A goal analogous to `first`/`head`/`car`.

Parameters
----------
l: form or `LVar`
  The object to which the `first` operation is applied.
a: symbol or `LVar`
  An object representing the result of a `first` operation
  applied to `l`.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (fresh [d]
         (≡ (cons a d) l)))

(defn-alias [restᵒ resto] [l d]
  "A goal analogous to `rest`/`tail`/`cdr`.

Parameters
----------
l: form or `LVar`
  The object to which a `rest` operation is applied.
d: form or `LVar`
  The object representing the result of a `rest` operation.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (fresh [a]
         (≡ (cons a d) l)))

(defn-alias [emptyᵒ emptyo] [l]
  "A goal stating the emptiness of a list.

Parameters
----------
l: form or `LVar`
  The object for which emptiness is assumed.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (≡ [] l))

(defn-alias [eqᵒ eqo] [u v]
  "A synonym for ≡.

See `≡`/`==`."
  (≡ u v))

(defn-alias [pairᵒ pairo] [l]
  "A goal that assigns the property of being a pair (i.e. made from a `cons`
between two elements).

Examples
--------
  => (run* [q] (pairo q))
  [(<'_.0'> . <'_.1'>)]

In this example, the output consists of two reified fresh variables representing
the car and cdr that comprise our `LVar` `q`.


Parameters
----------
l: form or `LVar`
  The object assumed to be a pair.

Returns
-------
out: A goal establishing the aforementioned properties to its input.
"
  (fresh [a d]
         (consᵒ a d l)))

(defn-alias [listᵒ listo] [l]
  "A goal stating that its argument is a list (i.e. made of pairs/conses of
pairs/conses).

Examples
--------
  => (run 3 [q] (listo q))
  [[], [<'_.0'>], [<'_.0'>, <'_.1'>]]

For fun, try running `(run* [q] (listo q))`!

Parameters
----------
l: form or `LVar`
  The object assumed to be a list.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (condᵉ
   [(emptyᵒ l) succeed]
   [(pairᵒ l)
    (fresh [d]
           (restᵒ l d)
           (listᵒ d))]
   (else fail)))

(defn-alias [lolᵒ lolo] [l]
  "A goal stating that its argument is a list of lists.

Examples
--------
  => (run 3 [q] (lolo q))
  [[], [[]], [[], []]]

For fun, try running `(run* [q] (lolo q))`!

Parameters
----------
l: form or `LVar`
  The object assuming the list-of-lists property.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (condᵉ
   [(emptyᵒ l) succeed]
   [(fresh [a]
           (firstᵒ l a)
           (listᵒ a))
    (fresh [d]
           (restᵒ l d)
           (lolᵒ d))]
   (else fail)))

(defn-alias [twinsᵒ twinso] [s]
  "A goal stating that a form is a pair of the same values.

Examples
--------
  => (run* [q] (twinsᵒ q))
  [[<'_.0'>, <'_.0'>]]

Parameters
----------
l: form or `LVar`
  The object assuming the given property.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (fresh [x]
         (≡ [x x] s)))

(defn-alias [lotᵒ loto] [l]
  "A goal stating that a form is a list of twins.

See `twinsᵒ`.

Examples
--------
  => (run* [q] (twinsᵒ q))
  [[<'_.0'>, <'_.0'>]]

Parameters
----------
l: form or `LVar`
  The object assuming the given property.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (listofᵒ twinsᵒ l))

(defn-alias [listofᵒ listofo] [predᵒ l]
  "A goal stating that a form is a list of forms satisfying a given
predicate goal.

Examples
--------
  => (run 3 [q] (listofᵒ twinsᵒ q))
  [[<'_.0'>, <'_.0'>]]

Parameters
----------
predᵒ: a goal
  The predicate goal that must apply to elements of `l`.
l: form or `LVar`
  The object assuming a list property with elements
  satisfying `predᵒ`.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (condᵉ
   [(emptyᵒ l) succeed]
   [(fresh [a]
           (firstᵒ l a)
           (predᵒ a))
    (fresh [d]
           (restᵒ l d)
           (listofᵒ predᵒ d))]))

(defn-alias [memberᵒ membero] [x l]
  "A goal stating that a form is a member of another.

Examples
--------
  => (run 3 [q] (memberᵒ 'a q))
  [(a . <'_.0'>),
   (<'_.0'> . (a . <'_.1'>)),
   (<'_.0'> . (<'_.1'> . (a . <'_.2'>)))]

Parameters
----------
x: form or `LVar`
  The element for which membership in `l` is assumed.
l: form or `LVar`
  The object for which membership of `x` is assumed.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (condᵉ
   [(firstᵒ l x) succeed]
   (else (fresh [d]
                (restᵒ l d)
                (memberᵒ x d)))))

(defn-alias [pmemberᵒ pmembero] [x l]
  "A goal stating that a form is a member of another form.

This version returns proper lists in the even positions of its results.

See `pmemberᵒ`

Examples
--------
  => (run 4 [q] (pmemberᵒ 'a q))
  [(a . (<'_.0'> . <'_.1'>)),
   [a],
   (<'_.0'> . (a . (<'_.1'> . <'_.2'>))),
   [<'_.0'>, a]]

Parameters
----------
x: form or `LVar`
  The element for which membership in `l` is assumed.
l: form or `LVar`
  The object for which membership of `x` is assumed.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (condᵉ
   [(firstᵒ l x)
    (fresh [a d]
           (restᵒ l (cons a d)))]
   [(firstᵒ l x) (restᵒ l [])]
   (else (fresh [d]
                (restᵒ l d)
                (pmemberᵒ x d)))))

(defn-alias [memberrevᵒ memberrevo] [x l]
  "A goal stating that a form is a member of another.

This version computes the results in the reverse of `memberᵒ`.

See `memberᵒ`.

Examples
--------
  => (run 3 [q] (memberrevᵒ q [1 2 3]))
  [3, 2, 1]
  => (run 3 [q] (memberrevᵒ 'a q))
  ...will not yield results because there is no end to the possible lists...

Parameters
----------
x: form or `LVar`
  The element for which membership in `l` is assumed.
l: form or `LVar`
  The object for which membership of `x` is assumed.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (condᵉ
   [succeed (fresh [d]
               (restᵒ l d)
               (memberrevᵒ x d))]
   (else (firstᵒ l x))))

(defn-alias [memᵒ memo] [x l out]
  "A goal stating that a form is the sublist starting from the first
occurrence of another form.

This is like Common Lisp's `member`.

Examples
--------
  => (run* [q] (memᵒ 2 [1 2 3] q))
  [[2, 3]]

Parameters
----------
x: form or `LVar`
  The element for which membership in `l` is assumed.
l: form or `LVar`
  The object for which membership of `x` is assumed.
out: form or `LVar`
  The object representing the sublist of `l` starting at `x`.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (condᵉ
   [(firstᵒ l x) (≡ l out)]
   [(fresh [d]
           (restᵒ l d)
           (memᵒ x d out))]))

(defn-alias [rememberᵒ remembero] [x l out]
  "A goal stating that a form is all sequentially computed subsets of another
form with an element removed from each position.

Examples
--------
  => (run* [q] (rememberᵒ 1 [1 2 1 3 4] q))
  [[2, 1, 3, 4], [1, 2, 3, 4], [1, 2, 1, 3, 4]]

Parameters
----------
x: form or `LVar`
  The element for which membership in `l` is assumed.
l: form or `LVar`
  The object for which membership of `x` is assumed.
out: form or `LVar`
  The object representing the sequentially computed sublist of `l` with `x`
  removed from one position.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (condᵉ
   [(emptyᵒ l) (≡ [] out)]
   [(firstᵒ l x) (restᵒ l out)]
   [(fresh [a d res]
           (consᵒ a d l)
           (rememberᵒ x d res)
           (consᵒ a res out))]))

(defn-alias [appendᵒ appendo] [l s out]
  "A goal stating that a form is the result of appending two other forms.

Examples
--------
  => (run* [q] (appendᵒ [1 2] q [1 2 3 4]))
  [[3, 4]]

Parameters
----------
l: form or `LVar`
  The object comprising the first/car of `out`.
s: form or `LVar`
  The object comprising the rest/cdr of `out`.
out: form or `LVar`
  The object representing concatenation/cons of `l` and `s`.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (condᵉ
   [(emptyᵒ l) (≡ s out)]
   [(fresh [a d res]
           (consᵒ a d l)
           (consᵒ a res out)
           (appendᵒ d s res))]))

(defn-alias [unwrapᵒ unwrapo] [x out]
  "A goal stating that a form is the result of unnesting/unwrapping another.

Examples
--------
  => (run* [q] (unwrapᵒ [[1]] q))
  [[[1]], [1], 1]

Parameters
----------
x: form or `LVar`
  The object assumed to be nested/wrapped.
out: form or `LVar`
  The object representing the unnested/unwrapping `x`.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (condᵉ
   [succeed (≡ x out)]
   [(pairᵒ x)
    (fresh [a]
           (firstᵒ x a)
           (unwrapᵒ a out))]))

(defn-alias [flattenᵒ flatteno] [s out]
  "A goal stating that a form is the result of flattening another.

Examples
--------
  => (run 3 [q] (flattenᵒ [[1]] q))
  [[1], [1, []], [1, []]]

Parameters
----------
s: form or `LVar`
  The object assumed to be flattened.
out: form or `LVar`
  The object representing the flattening of `s`.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (condᵉ
   [(emptyᵒ s) (≡ [] out)]
   [(pairᵒ s)
    (fresh [a d res-a res-d]
           (consᵒ a d s)
           (flattenᵒ a res-a)
           (flattenᵒ d res-d)
           (appendᵒ res-a res-d out))]
   (else (consᵒ s [] out))))

(defn-alias [flattenrevᵒ flattenrevo] [s out]
  "A goal stating that a form is the result of flattening another.

This computes the results in reverse of `flattenᵒ`.

See `flattenᵒ`.

Examples
--------
  => (run 3 [q] (flattenrevᵒ [[1]] q))
  [[[[1]]], [[1], []], [[1]]]

Parameters
----------
s: form or `LVar`
  The object assumed to be flattened.
out: form or `LVar`
  The object representing the flattening of `s`.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (condᵉ
   [succeed (consᵒ s [] out)]
   [(emptyᵒ s) (≡ [] out)]
   [(pairᵒ s)
    (fresh [a d res-a res-d]
           (consᵒ a d s)
           (flattenrevᵒ a res-a)
           (flattenrevᵒ d res-d)
           (appendᵒ res-a res-d out))]))

(defn-alias [anyᵒ anyo] [g]
  "A goal that is successful if its argument is ever successful.

This is a recursive goal that indefinitely generates new `conde` branches, so,
that the argument goal of `anyᵒ` may be given a chance to succeed by way of the
associations/unifications made by other goals.

Examples
--------
  TODO: Add an illustrative example.

Parameters
----------
g: symbol or `LVar`
  The object assuming the given property.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (condᵉ
   [g succeed]
   (else (anyᵒ g))))

(setv neverᵒ (anyᵒ fail))
(setv nevero neverᵒ)
(setv nevero.__doc__
      "A goal that never succeeds.

While `u#` is a goal that is unsuccessful, it's only unsuccessful once, yet
`neverᵒ` is unsuccessful indefinitely.

Examples
--------
  => (run* [q] u# neverᵒ)
  []
  => (run¹ [q] neverᵒ u#)
  ...RecursionError or endless loop...
  => (run¹ [q] s# neverᵒ)
  ...RecursionError or endless loop...
  => (run¹ [q] neverᵒ s#)
  ...RecursionError or endless loop...

Returns
-------
out: A goal stating the given relation between its arguments.
")

(setv alwaysᵒ (anyᵒ succeed))
(setv alwayso alwaysᵒ)
(setv alwayso.__doc__
      "A goal that always succeeds.

While `s#` is a goal that succeeds, it only succeeds once, yet `alwaysᵒ`
succeeds indefinitely.

Examples
--------
  => (run* [q] u# alwaysᵒ)
  []
  => (run¹ [q] alwaysᵒ u#)
  ...RecursionError or endless loop...
  => (run 3 [q] alwaysᵒ (== q True))
  [True, True, True]

Returns
-------
out: A goal stating the given relation between its arguments.
")

(defn-alias [salᵒ salo] [g]
  "A goal representing the objective \"succeed at least once\" for a given goal.

See `anyᵒ`

Examples
--------
  TODO: Add an illustrative example.

Parameters
----------
g: symbol or `LVar`
  The object assuming the given property.

Returns
-------
out: A goal stating the given relation between its arguments.
"
  (condᵉ
   [succeed succeed]
   (else g)))
